<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kakudo Kentaro</title><link>https://kakudokentaro.com/</link><description>Recent content on Kakudo Kentaro</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sat, 03 Sep 2022 06:38:53 +0900</lastBuildDate><atom:link href="https://kakudokentaro.com/index.xml" rel="self" type="application/rss+xml"/><item><title>禁忌かもしれない未読マークと、消えないCSS疑似要素</title><link>https://kakudokentaro.com/blog/2022/09/03/unread-marker/</link><pubDate>Sat, 03 Sep 2022 06:38:53 +0900</pubDate><guid>https://kakudokentaro.com/blog/2022/09/03/unread-marker/</guid><description>未読マークの魔力 未読マークってどうしてあんなに消したくなるんでしょうか。特に用のないアプリ、今読まなくてもよいメールでも、未読マークのためについつい一度開いたりしてしまいます。
整然と並んだ「既読たち」の中に、目立つはみ出し者の「未読」がいると気持ち悪くなる人間の習性でもあるのかもしれません。
さて、おもしろそうだったのでそんな未読マークを実装してみました。まだお読みでない記事があったらブログ記事一覧を見てみてください。このように青い点が未読記事の右に表示されているはずです。
実装といっても、既読かどうかはブラウザが判断してくれるので簡単です。
a.unread-marker { display: flex; align-items: center; } a.unread-marker::after { content: &amp;#34;&amp;#34;; display: block; height: 0.5rem; width: 0.5rem; margin-left: auto; flex-shrink: 0; border-radius: 50%; background: #0077C8; } a.unread-marker:visited::after { display: none; } 未読マークを付けたいリンクに対して、CSSの疑似要素でマークを作ればよいです。
なぜか消えない ::after 起こったこと 未読マークの役割から言って、読んだ記事の横にあるマークは当然消すべきです。そこで以下のように書いているわけですが、なぜか疑似要素::afterが消えません･･･。
a.unread-marker:visited::after { display: none; } 消す系の指定をてんこ盛りにしてもダメでした。
a.unread-marker:visited::after { content: none; display: none; visibility: hidden; } ブラウザの開発者ツールを確認すると正常にdisplayを上書きできているように見えます。
しかし、計算済みタブを見ると、display: noneが認識されていながらdisplay: blockが使われています。不思議です。
理由 プライバシー上の理由から、:visited疑似クラスではdisplay等が使えないことが原因でした。
プライバシーと :visited セレクター - CSS: カスケーディングスタイルシート | MDNには、次のように書かれています。（参照: 2022-09-03）</description></item><item><title>このサイトを作るときに気をつけたこと</title><link>https://kakudokentaro.com/blog/2022/09/01/points/</link><pubDate>Thu, 01 Sep 2022 14:44:06 +0900</pubDate><guid>https://kakudokentaro.com/blog/2022/09/01/points/</guid><description>どのようなことを考えながらこのサイトを作ったかを、忘れないうちに書き留めたいと思います。
簡素なデザインにすること 「software engineer portfolio」とか「designer portfolio」とかを調べてみると、目を見張るような美しいウェブサイトの数々を見ることができます。 しかし、いざアクセスしてみるとどこに何があるか分かりづらかったり、スクロールを持っていかれたりと、思ったより使いやすくありません。 そのため、いっそ目を引かなくてもいいから、シンプルにしようと考えました。
2年くらい経って今のデザインに飽きた僕が計画性の無いリニューアルをしないように、戒めとして書いておきます。
長期間使えるURLにすること 完全なる、クールなURIは変わらない &amp;ndash; Style Guide for Online Hypertextの受け売りです。
述べられているアドバイスに従って、時間が経ってもURLを変えなくて済むように気をつけました。 たとえば、なるべく日付以外の情報をURL（URI）に含めないようにしています。（Blogである以上日付だけというわけにはいきませんが。）
また、個人的な話ですが、ドメインもハンドルとしてよく使っているkakudo415.comではなくkakudokentaro.comにしました。 ハンドルを変えたくなることはあっても、名前そのものが変わることはそう無いだろうと考えたからです。
この行いの真価が発揮されるのは少なくとも10年経ってからなので、辛抱強く続けたいと思います。 そういう意味では上の記事は少なくとも2001年11月からあるらしく、20年以上同じURLで公開されているのは偉業ですね。（ほとんど僕の半生です）
メンテナンスを簡単にすること 今までVPSを使ってWebページやWebアプリをホストすることが多かったのですが、よく証明書の期限を切らしてアクセスできなくしたりしてしまっていました。 証明書だけであれば定期的に更新するスクリプトを置いておけば良いですが、それ以外にもいろいろ手が回らずいつの間にかサイトが死んでる･･･ということが多々あったため、自分の面倒くさがりを認めGitHub Pagesに頼ることとします。
GitHub ActionsからHugoを利用して静的にサイトを構築しているので、手間もトラブルもずっと少ないはずです。（天下のGitHubがホストしてくれますからね）</description></item><item><title>HugoとGitHub Pagesでハマったこと</title><link>https://kakudokentaro.com/blog/2022/09/01/hugo-failure/</link><pubDate>Thu, 01 Sep 2022 10:54:12 +0900</pubDate><guid>https://kakudokentaro.com/blog/2022/09/01/hugo-failure/</guid><description>このページを作る過程でハマったこととその対処法について書きます。
静的なファイルが配信されない・パスがおかしい Hugoは/static/内のファイルを配信してくれますが、中身がそのままルート直下に置かれます。たとえば/static/hoge.fugaというファイルにアクセスしたいときは、https://example.com/static/hoge.fugaではなく、https://example.com/hoge.fugaとしなくてはなりません。これに気づかなかったため、前者のURLで404を吐き続けていました。
この仕様で問題となりそうなのが、/static/以下のファイル・ディレクトリ名とページ名が被ることです。そのため、/static/assets/のようにもう一段ディレクトリを深くして、https://example.com/assets/hoge.fugaのように静的ファイルをひとまとめに配信するようにしました。
設定ファイルでなんとかできると綺麗なのですが･･･
Trailing Slash（URL末尾のスラッシュ）を無くせない ここを読む限り、サーバー側で対処する以外に解決策が無さそうです。
Trailing Slashは無いのが好みなのですが、天下のW3Cのブログ（下記）が有りのスタイルなのでこれに倣ったと思い納得することとします。
https://www.w3.org/blog/2022/08/https-redirection-observations/
GitHub Pagesに設定したはずのCustom domainが消える 当初は問題なくページを閲覧できるのに、しばらくすると404になり、設定したはずのCustom domainが消えているという症状です。
原因は、Custom domain設定時に自動的に追加されたCNAMEファイルを、GitHub Actionsが消し飛ばしてしまったからでした。 新しい公開ファイルでgh-pagesブランチを更新するときに、CNAMEファイルごと置き換えてしまっているわけです。
対処法 /static/下に、直接CNAMEファイルの内容を書いておけば良いです。 /static/ディレクトリの内容は、生成時に公開ディレクトリ直下にそのままコピーされます。
というか、Host on GitHub | Hugoにめちゃくちゃ丁寧に書いてありました。ちゃんと読まないのが悪い･･･。n敗目。</description></item><item><title>【旧ブログ記事】HubotでSlackにattachments付きのリッチなメッセージを送る</title><link>https://kakudokentaro.com/blog/2018/08/29/hubot-slack-attachments/</link><pubDate>Wed, 29 Aug 2018 00:00:00 +0900</pubDate><guid>https://kakudokentaro.com/blog/2018/08/29/hubot-slack-attachments/</guid><description>この記事は以前のブログから引っ越してきたものです！
以前のブログのGitHubリポジトリ こんにちは、今回はJavaScriptでSlackにリッチなメッセージをHubotを使って送りたいと思います（今回は備忘録的な記事です）
調べてもCoffeeScriptの情報が多かったりしてわかりにくかったので、出来たことを書いていきます
また2018年8月時点での情報ですので（hubot-slack version 4.5.4）、未来からご覧の方はうまく動かない可能性があります
データ構造 hubot-slackは所定の形のObjectを渡してやることで、通常の使用では使えないリッチな表現をすることができます（attachments）
let msg = new Object; msg = { attachments: [ // 配列なので注意！複数同時に送れます { title: "太字になり最初の記載されます", text: "本文です", fields: [ // フィールドも配列です、複数化 { title: "フィールドのタイトルです", value: "フィールドの内容", short: true // 十分横幅が小さいか？trueの場合２列に並べられます } ] } ] } 全て書いていませんがこのようにattachments配列の中に書いていくことでデザインが可能です
さらに知りたい方はSlack Attachmentsをご覧ください
Slackに投稿する robot.send({room: '送り先のチャンネル名'}, msg); このようにObjectを使ってチャンネルを指定して投稿できます
短い記事でしたが、意外と簡単にSlackのリッチなメッセージを作成できることがお分りいただけたかと思います</description></item><item><title>【旧ブログ記事】nginxでrewriteを使わずにディレクトリ構造にするproxy_pass</title><link>https://kakudokentaro.com/blog/2018/08/22/nginx-dir/</link><pubDate>Wed, 22 Aug 2018 00:00:00 +0900</pubDate><guid>https://kakudokentaro.com/blog/2018/08/22/nginx-dir/</guid><description>この記事は以前のブログから引っ越してきたものです！
以前のブログのGitHubリポジトリ こんにちは、今回はこのブログのようにドメインの後ディレクトリを挟んでアプリケーションを動かすときにrewriteを使わない方法をご説明します
locationで正規表現を使う locationを指定するところで下のようにチルダ等を入れることで単に前方一致ではない正規表現を使うことができます
location = 完全一致 {} location ^~ 正規表現(マッチしたら検索終了) {} location ~ 正規表現 {} location ~* 正規表現(大文字小文字区別しない) {} マッチした文字列を変数にする location ~ (?&amp;lt;変数名&amp;gt;正規表現) {} このように変数名を指定して正規表現を使いかっこで括ることでlocation内で使える変数を作ることができます（変数名は既存のものと被らないように）
そしてこのように書くことで
location ~ /dir/(?&amp;lt;path&amp;gt;.*) { proxy\_pass http://localhost:12345/$path$is\_arg$args; } $path には/dir/以下のURLが入り、
$is_args にはクエリがある場合に ? が入り、
$args にクエリが入るので、正しく/dir/を飛ばしてリバースプロキシできるわけですね
最後に(rewriteとの比較) 自分の環境ではrewrite時にPOSTするとうまくいかないところがあったので他のやり方を探したところこれが良さそうだと思いました</description></item><item><title>【旧ブログ記事】強制HTTPSのAPPドメインでLet's Encryptを活用しよう！</title><link>https://kakudokentaro.com/blog/2018/08/09/new-app-domain/</link><pubDate>Thu, 09 Aug 2018 00:00:00 +0900</pubDate><guid>https://kakudokentaro.com/blog/2018/08/09/new-app-domain/</guid><description>この記事は以前のブログから引っ越してきたものです！
以前のブログのGitHubリポジトリ こんにちは！今日は自分の新しいドメイン kakudo.app についてです
ほかのドメインと何が違うのか？ .appは今年(2018)の5月から運用が開始されたGoogle謹製の新作TLDです
Googleが当時過去最高の2500万ドル(約30億円)で競り落としたことで話題にもなりました
しかし、appドメインが他と違うのは落札額だけではありません
サイトをHTTPS化するのが 強制 です(HTTP Strict Transport Security)
.appドメインの使用が広がったり、同じようなHTTPS強制のドメインが増えれば、さらにWebの暗号化が進むと思われます
Let&amp;rsquo;s Encryptとは？ Let&amp;rsquo;s Encryptとは、HTTPS接続をするために必要なSSL証明書を無料で発行してくれる機関です
簡単な手続きで今あるサイトをHTTPS化することができます
今回はこのLet&amp;rsquo;s Encryptの力を借りて強制HTTPSに対応したいと思います
自分の環境 Ubuntu 18.04 LTS nginx (Let&amp;rsquo;s Encryptの使用にはWebサーバーが必要です 他のWebサーバーも可) letsencrypt (aptでインストールしておいてください) やってみる Let&amp;rsquo;s Encryptのアクセスへの準備 まずは通常の通常のHTTPで認証用のアクセスを受け付ける準備をします(/etc/nginx/conf.d/hogehoge.conf内に追記)
server { listen 80; listen [::]:80; server\_name kakudo.app; location / { return 301 https://$server\_name$request\_uri; } location /.well-known/acme-challenge/ { root /var/www/letsencrypt; } } この次に誤字脱字などが無いか、テストコマンドを実行します
sudo nginx -t 成功したら次のコマンドでnginxを再読み込みします(エラーが出たら間違いがないか確認してください)
sudo nginx -s reload コマンド実行で証明書を発行する sudo letsencrypt certonly --webroot -w /var/www/letsencrypt/ -d kakudo.</description></item><item><title>【旧ブログ記事】初マイコンにPro Microを選んでしまったので、使い方メモ</title><link>https://kakudokentaro.com/blog/2018/08/07/promicro-tutorial/</link><pubDate>Tue, 07 Aug 2018 00:00:00 +0900</pubDate><guid>https://kakudokentaro.com/blog/2018/08/07/promicro-tutorial/</guid><description>この記事は以前のブログから引っ越してきたものです！
以前のブログのGitHubリポジトリ こんにちは Kakudo です 今回は、タイトルの通り初めての電子工作（自作キーボード）のためにPro Microを買ったけど使い方全く分からなかったので、同じように爆死した同志達のためにメモを残したいと思います。
他の有名マイコンとの違い この記事を見ている人はたいてい「Arduino Leonardo」とか「Arduino Micro」と同じことができる安いボードとして「Pro Micro」を買っていると思うのですが、Leonardoとかを前提にした解説サイトが多いのでどう読みかえればいいのかを書いていきます
SparkFunの公式ガイド、読める人はこれ読んだほうが絶対正確ですｗ
そもそもArduino IDEにPro Microないんやけど！ 残念ながらPro MicroはArduino公式マイコンではないので公式サポートがありません
しかし、Pro Micro製造元のSparkFunが配布しているアドオンを追加することで普通に使えるようになります
https://raw.githubusercontent.com/sparkfun/Arduino_Boards/master/IDE_Board_Manager/package_sparkfun_index.json このURLをArduino IDEの環境設定内の追加のボードマネージャのURLのところに追記します
どこが5Vピンなんだよ！ Leonardoとかには常に5Vを出力してくれる5Vピンがあるらしい、だけどPro Microには無い・・・
自分が初めにぶつかったのがこの問題、結論から言うと公式に書いてありましたｗ
結論から言うとRAWかRSTかVCCを使うと良さげです。
テスターを使って図ってみたところRAW-GND間、RST-GND間、VCC-GND間のどちらにも4.7V程度の電気が流れていました（GNDはマイナスとして働くとのことです）
やってみる とりあえずLチカやろうず 電子工作の世界ではLEDをチカチカさせるのがプログラムでいう Hello World 的な立ち位置らしい
だけど、外部にわざわざLEDと導線用意するのはめんどくさいのでProMicroに乗っているLEDを使ってやってみる
void setup() {} // Pro Microの起動時に一回だけ呼ばれる関数、今回は使わない void loop() { // その名の通り起動中はこの関数が繰り返し呼ばれる digitalWrite(17, HIGH); // 17番ピンに電気を流す（今回は何も繋いでいないが内部でオンボードLEDと繋がっている） delay(1000); // 1000ミリ秒 = 1秒待つ digitalWrite(17, LOW); // 17番ピンの電気を止める（LEDが消える） delay(1000); // また1秒待つ } このプログラムをArduino IDEを使って書き込んでみるとゆっくりLEDが点滅させることができる
電気が流れてるか判定しよう キーボード作るときに必要になる電気が流れているかの判定（スイッチがオンかどうか）
さっき何気なく使ったdigitalWriteやdelay関数、またHIGHなどの定数値はどこかで宣言されているみたいなので気にせず使っていいです</description></item><item><title>【旧ブログ記事】二代目のブログができました</title><link>https://kakudokentaro.com/blog/2018/08/05/blog2gen/</link><pubDate>Sun, 05 Aug 2018 00:00:00 +0900</pubDate><guid>https://kakudokentaro.com/blog/2018/08/05/blog2gen/</guid><description>この記事は以前のブログから引っ越してきたものです！
以前のブログのGitHubリポジトリ 今回は新しく作ったブログシステムの紹介です
dev.toを参考に高速化に全振りしてます
インラインCSS 凝ったCSSを使わず、さらにHTMLに直接埋め込むことで１ファイルの転送をしています
HTMLの構造化した文書という作法においてはよくないかもしれませんが、早くなるはず・・
JavaScriptの遅延読み込み &amp;lt;script src=&amp;#34;hogehoge&amp;#34; defer=&amp;#34;defer&amp;#34;&amp;gt; 上のようにすることでJavaScriptを遅延読み込みすることができます
これによりページ読み込み時にJavaScriptを実行しないので、ファーストビュー表示が早くなります
ページ読み込み時に呼ばれなかったJavaScriptはページレンダリングが終わってから読み込まれます
そもそも要らないものは読み込まない PureJSを使い、ライブラリなどに依存しないことで、外部ライブラリの読み込み時間を無くせる
「シンタックスハイライトくらいはあってもいいかな」とも思う（読み込むとしてもdeferするけど）
クリック先読み（InstantClick） dev.toでも採用されているクリックではなくマウスオンした時点でAjaxを使いGETする仕組み
そしてクリック時にはすでに取得してあるデータを使ってHTMLを差し替えるだけなのでユーザーに遅延を感じさせにくい
なお導入方法がわからなかったので自分で書くはめになった（かなり時間がかかった）
なおブラウザ、マウスなどの進む戻るボタンには未対応なので早急に対応します（現状リロードで対処してます(´・ω・`)）
Markdownでの執筆 今回のブログはMarkdownで書けるようになっています
以前はHTMLファイルをコマンドラインでデータベースに入れる形式だったので、かなりモチベーションに影響しましたが、今回はよく書ける・・はず
GoでのMD HTML変換には、blackfridayを使用しました
最後に 結局は本番環境（ConoHa VPS + nginx）で動かしてみないとわからないので 環境に合わせて調整して瞬きを追い抜くサイトを目指したいと思います</description></item><item><title>About Me</title><link>https://kakudokentaro.com/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kakudokentaro.com/about/</guid><description>(TODO: More information)
I am a Software Engineer who is interested in Web Development.
Skills Programming Languages Go Gin Echo Rust JavaScript Languages Japanese Native.
English Chinese Korean Works Experience Education N High School 2017.04.01 - 2020.03.31
Tokyo University of Science Department of Mathematics, Faculty of Science and Technology
2020.04.01 -</description></item></channel></rss>