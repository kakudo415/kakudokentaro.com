<!doctype html><html lang=ja prefix="og: https://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=preload href=https://kakudokentaro.com/assets/fonts/Inter-SemiBold.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://kakudokentaro.com/assets/fonts/Inter-Regular.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://kakudokentaro.com/assets/css/null-2.4.css><link rel=stylesheet href=https://kakudokentaro.com/assets/css/common.css><link rel="shortcut icon" href=https://kakudokentaro.com/assets/favicon.svg type=image/svg+xml><link rel=stylesheet href=https://kakudokentaro.com/assets/css/document.css><link rel=stylesheet href=https://kakudokentaro.com/assets/css/single.css><title>UnicodeとUTF-8の違い、Rustでの扱いも - Kakudo Kentaro</title><meta property="og:title" content="UnicodeとUTF-8の違い、Rustでの扱いも - Kakudo Kentaro"><meta property="og:type" content="website"><meta property="og:image" content="https://kakudokentaro.com/assets/icon.png"><meta property="og:url" content="https://kakudokentaro.com/blog/2022/09/23/unicode-utf8/"><meta property="og:site_name" content="Kakudo Kentaro"><meta name=twitter:card content="summary"><meta name=twitter:creator content="@kakudo415"></head><body><header><div class=inner><h1><a href=https://kakudokentaro.com/>Kakudo Kentaro</a></h1><a href=https://kakudokentaro.com/blog/>Blog</a>
<a href=https://kakudokentaro.com/about/>About</a></div></header><main><div class=inner><h1>UnicodeとUTF-8の違い、Rustでの扱いも</h1><time datetime=2022-09-23>2022-09-23 02:18</time><ul class=tags><li><a href=https://kakudokentaro.com/blog/tags/rust/>Rust</a></li></ul><p>知らなかったため備忘録です。</p><h2 id=unicodeとutf-8>UnicodeとUTF-8</h2><p><a href=https://ja.wikipedia.org/wiki/Unicode>Unicode - Wikipedia</a>の受け売り情報です。</p><p>Unicodeは文字コードの規格、UTF-8はUnicodeの文字符号化形式のひとつ。</p><p>文字と、実際のファイル等での表現の間には、ざっくり2段階の対応があります。
文字と符号位置の対応と、符号位置と符号単位列の対応です。</p><p>実際は、エンディアンの問題が絡みもう一段ありますが、今回は取り扱いません。</p><h3 id=文字と符合位置>文字と符合位置</h3><p>これがいわゆる「文字コード」にあたるもので、現実世界の文字（抽象文字）に符号位置と呼ばれる整数値を割り当てたものです。</p><p>Unicodeにおける例をいくつか挙げます。</p><table><thead><tr><th>抽象文字</th><th style=text-align:right>符号位置</th></tr></thead><tbody><tr><td>A</td><td style=text-align:right>65</td></tr><tr><td>あ</td><td style=text-align:right>12354</td></tr><tr><td>🤔</td><td style=text-align:right>129300</td></tr></tbody></table><h3 id=符号位置と符号単位列>符号位置と符号単位列</h3><p>先ほどの対応関係によって数値となった文字たちを、コンピューターで扱える形（符号単位列）にするのがこの変換です。</p><p>多くのコンピューターではデータをバイト単位で管理していますが、たとえば<code>12354</code>をどのようにバイト区切りにするかというのは自明ではありません。
ここで登場するのが、UTF-8などの符号化形式です。</p><p>UTF-8では、ASCII文字と互換性を保ったまま、符号位置を1～4バイトに変換します。
詳しくは<a href=https://ja.wikipedia.org/wiki/UTF-8>UTF-8 - Wikipedia</a>を見ていただきたいですが、「あ」の場合は<code>111000111000000110000010</code>となります。</p><pre tabindex=0><code>111000111000000110000010 (全体)
    0011  000001  000010 (意味を持つビット)
</code></pre><p>3バイトで表現される「あ」の場合、下の行に抜き出した16ビットが実際に符号位置を表しています。
桁を詰めて<code>0011000001000010</code>とし、10進法に変換すると<code>12354</code>となり、先ほどの表に出てきた符号位置がちゃんと表現されていたことがわかります。</p><h2 id=rustでの取り扱い>Rustでの取り扱い</h2><p>さて、非常にややこしいことに、<code>String</code>はUTF-8が、<code>char</code>ではUnicodeが使われています。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#000;font-weight:700>fn</span> <span style=color:#900;font-weight:700>main</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>let</span><span style=color:#bbb> </span>as_string<span style=color:#bbb> </span><span style=color:#000;font-weight:700>=</span><span style=color:#bbb> </span><span style=color:#d14>&#34;あ&#34;</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>let</span><span style=color:#bbb> </span>as_char<span style=color:#bbb> </span><span style=color:#000;font-weight:700>=</span><span style=color:#bbb> </span><span style=color:#d14>&#39;あ&#39;</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>for</span><span style=color:#bbb> </span>c<span style=color:#bbb> </span><span style=color:#000;font-weight:700>in</span><span style=color:#bbb> </span>as_string.bytes()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>print!(<span style=color:#d14>&#34;</span><span style=color:#d14>{:b}</span><span style=color:#d14> &#34;</span>,<span style=color:#bbb> </span>c);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>println!();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>println!(<span style=color:#d14>&#34;</span><span style=color:#d14>{:b}</span><span style=color:#d14>&#34;</span>,<span style=color:#bbb> </span>as_char<span style=color:#bbb> </span><span style=color:#000;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#458;font-weight:700>u32</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><pre tabindex=0><code>11100011 10000001 10000010 
11000001000010
</code></pre><p>たとえば、上記のコードを実行してみると上のようになります。
これでは見にくいので、桁だけ揃えましょう。</p><pre tabindex=0><code>11100011 10000001 10000010 
           110000 01000010
</code></pre><p>このように、同じ「あ」でも<code>String</code>と<code>char</code>では内部表現が違い、前者はUTF-8を用いてエンコーディングされ、後者は符号位置がそのままになっています。</p><p>現在テキストエディタを開発していて、キーボードから入力されたUTF-8形式の文字を<code>char</code>として得たい場面があり、見事にハマったためこの記事が生まれました。
結局のところ、ビット演算をして符号位置を取り出してから<code>char::from_u32()</code>する汚いコードを書くはめになりました。
何かもっと良い方法があるように思いますが、とりあえずは仕方ありません。</p><section class=share><div>Share on</div><a href="https://twitter.com/intent/tweet?text=Unicode%e3%81%a8UTF-8%e3%81%ae%e9%81%95%e3%81%84%e3%80%81Rust%e3%81%a7%e3%81%ae%e6%89%b1%e3%81%84%e3%82%82 - Kakudo%20Kentaro&url=https%3a%2f%2fkakudokentaro.com%2fblog%2f2022%2f09%2f23%2funicode-utf8%2f" rel="nofollow noopener noreferrer" target=_blank>Twitter</a></section></div></main></body></html>